# 数组(Array)

> 为什么从 0 开始编号，而不是 1

数组是一种`线性表`数据结构，用`连续`的内存空间，存储`相同类型`的数据。

## 线性表

数据排列成一条线，每个数据只有前后两个方向。数组，链表，队列，栈等都是线性表。

![linear](./img/b6b71ec46935130dff5c4b62cf273477.jpg)

## 随机访问

线性表+连续内存+相同类型，使得数组可以随机访问，但是删除，插入操作，需要搬移数据，保证内存连续。

### 不是查找

随机访问是 O(1)，查找是要遍历的，二分查找是 O(logn)

### e.g.

我们拿一个长度为 10 的 int 类型的数组 int[] a = new int[10]来举例。在我画的这个图中，计算机给数组 a[10]，分配了一块连续内存空间 1000 ～ 1039，其中，内存块的首地址为 base_address = 1000。

![int](./img/98df8e702b14096e7ee4a5141260cdc4.jpg)

```
a[i]_address = base_address + [i] * data_type_size
// data_type_size 元素大小 int 4字节
```

## 低效的插入和删除

### 插入

在某个位置 k 插入数据，需要把 k-n 数据往后移一位。

最好 O(1)，最坏 O(n)，平均 (1+2+...+n)/n=O(n)

数组如果不是排序的，可以把 k 移到最后，插入新的数据，这样就不用都移位了 O(1)。

![insert](./img/3f70b4ad9069ec568a2caaddc231b7dc.jpg)

### 删除

复杂度同上，要保证连续性。实际情况不是都要保证连续性。

如果将多个删除操作合并，标记被删除的元素，但是不操作数组删除，当数组没有更多内存存储数据时，一次性删除，这样就大大减少搬移的时间。

- JVM 标记清除垃圾回收算法

![del](./img/b69b8c5dbf6248649ddab7d3e7cfd7e5.jpg)

## 数组越界

```cpp
int main(int argc, char* argv[]){
    int i = 0;
    int arr[3] = {0};
    for(; i<=3; i++){
        arr[i] = 0;
        printf("hello world\n");
    }
    return 0;
}
```

数组大小为 3，a[0] a[1] a[2]，条件判断 i<3 而不是 i<=3，因此当 i=3 时仍然进了循环，执行 a[3]=0，导致数组越界，根据寻址公式，a[3] 会定位到不属于 数组 a 的内存上地址，这个地址刚好是 i 的地址，所以 a[3]=0 等于 i=0，导致无限循环。

### 越界检查

Java 会做越界检查，抛出错误 `java.lang.ArrayIndexOutOfBoundsException`。

```java
int[] a = new int[3];
a[3] = 10;
```

## 容器能否完全替代数组

很多语言提供了容器类，比如 Java 中的 ArrayList，C++ STL 的 vector。

`ArrayList` 的优势是将 `数组操作细节封装起来`，比如数据搬移，还有一个优势是 `支持动态扩容`。

当插入新数据时，如果内存不够，需要`申请更大的内存`，将原来的数据`复制过去`，然后`插入`新的数据。

ArrayList 会`自动扩容` 1.5 倍，但是申请内存和数据搬移比较`耗时`，所以最好`创建` ArrayList 时`指定数据大小`。

### 什么时候用数组而不是容器

如果是业务开发，容器首选，开发效率高，不会影响系统整体性能。如果是底层开发，比如开发网络架构，性能优化需要极致，首选 数组。

- Java ArrayList 不能存储基本类型，比如 int，long，需要封装为 Integer，Long 类，而 Autoboxing，Unboxing 有一定的性能损耗，可以选用 数组。
- 如果数据大小已知，并且对数据操作简单，用不到 ArrayList。
- 多维数组更加直观，`Object[][] arr`，容器复杂 `<ArrayList<ArrayList<object>> arr`。

## 数组下标从 0 开始

通过寻址公式可以看到，如果从 1 开始，每次访问数组需要做一次减法操作，对于 CPU 就多了一次 减法指令，访问操作又是普遍的操作，为了性能考虑减少不必要的计算。

```
// 0
a[k]_address = base_address + k * type_size

// 1
a[k]_address = base_address + (k-1)*type_size
```

最主要的原因可能是历史原因，C 语言是从 0 开始，之后的 Java，JavaScript 都效仿了 C，为了减少学习成本就沿用了。很多语言不是从 0 开始的，比如 Matlab，Python 还支持负数。

---

## Exercise

TODO

### 前面我基于数组的原理引出 JVM 的标记清除垃圾回收算法的核心理念。我不知道你是否使用 Java 语言，理解 JVM，如果你熟悉，可以在评论区回顾下你理解的标记清除垃圾回收算法。

### 前面我们讲到一维数组的内存寻址公式，那你可以思考一下，类比一下，二维数组的内存寻址公式是怎样的呢？
