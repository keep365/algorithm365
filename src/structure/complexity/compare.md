# 最好、最坏、平均、均摊

[上篇，算法复杂度](./note.md)

- 最好情况时间复杂度(best case time complexity)
- 最坏情况时间复杂度(worst case time complexity)
- 平均情况时间复杂度(avarage case time complexity)
- 均摊时间复杂度(amortized time complexity)

## 最好、最坏情况时间复杂度

```cpp
// n表示数组array的长度
int find(int[] array, int n, int x) {
  int i = 0;
  int pos = -1;
  for (; i < n; ++i) {
    if (array[i] == x) {
       pos = i;
       break; // 中断，不加 break 则一直都是 O(n)
    }
  }
  return pos;
}
```

- 如果第一个就是，那么复杂度为 `O(1)`，最好情况
- 如果一个都没有，那么复杂度为 `O(n)`，最坏情况

## 平均情况时间复杂度

最好和最坏是比较极端的情况，概率小，一般用平均的表示。

上面的例子，x 在数组种的位置一共有 n+1 种情况，在数组的 `0 ～ n-1 位置中` 和 `不在数组中`。

`平均值=总遍历次数/总情况`

```
位置 i，遍历次数 m

// 数组中
i=0, m=1
i=1, m=2
...
i=n-1, m=n

// 数组外
i=n-1, m=n

总次数 d= (1+2+...+n)+n
总情况 n+1

平均值 d/(n+1) = n(n+3) / 2(n+1)
```

![ava](./img/d889a358b8eccc5bbb90fc16e327a22f.jpg)

去掉低阶，常量，系数后，平均时间复杂度=`O(n)`

### 考虑概率

上文 `平均=总次数/总情况`，但是出现在数组中的某个位置的概率是不一样的，出现在数组中和不出现在数组中的概率也不是一样的。

真正的平均应该是`每个位置的概率`相加， `平均=位置0的概率+位置1的概率+...+位置n-1的概率 + 数组外的概率`，而不是总次数的概率。

在数组中和不在数组中的概率不要计算，假设都为 1/2，同样，在数组中某个位置的概率假设都为 1/n。

所以不在数组中的遍历次数的概率为 `n * 1/2`，在数组中某个位置的概率为 `1/2 * 1/n = 1/2n`，在数组中的遍历次数的总概率为 `1*(1/2n) + 2*(1/2n) + ... + n*(1/2n)`

```
平均=在数组中+不在数组中

1*(1/2n) + 2*(1/2n) + ... + n*(1/2n) + n*(1/2)

=(3n+1)/4
```

![ava-prob](./img/36c0aabdac69032f8a43368f5e90c67f.jpg)

这个值就是概率论中的 `加权平均值`，也叫 `期望值`，所以平均时间复杂度全称是 `加权平均时间复杂度` 或 `期望时间复杂度`。

引入概率后，复杂度还是 `O(n)`。

正常情况不需要分析 `最好、最坏、平均`，只有 `同一块代码在不同情况下，复杂度有量级的差距`，才会用三种表示。

## 均摊时间复杂度

```cpp
// array表示一个长度为n的数组
// 代码中的array.length就等于n
int[] array = new int[n];
int count = 0;

void insert(int val) {
  if (count == array.length) {
     int sum = 0;
     for (int i = 0; i < array.length; ++i) {
        sum = sum + array[i];
     }
     array[0] = sum;
     count = 1;
  }

  array[count] = val;
  ++count;
}
```

以上操作，数组有剩余空间的时候 `最好 O(1)`，没有剩余空间的时候 `最坏 O(n)`。

用概率来算平均，有 `n+1` 种情况，每种情况概率为 `1/(n+1)`，前面 n 次 都是有空间的时候，复杂度为 O(1)，后面一次是没有空间的时候，复杂度为 O(n)。

所以总平均的复杂度为 `1*(1/(n+1)) + 1*(1/(n+1)) + ... 前面的n次 ... + 1*(1/(n+1)) + n*(1/(n+1)) = O(1)`

![o1](img/6df62366a60336d9de3bc34f488d8bed.jpg)

比较下 `find` 和 `insert` 两个例子，`insert` 绝大多数情况都是 O(1) 的直接插入操作，只有当空间满了之后才会进行 O(n) 累加，之后再是 `n-1` 次的 `O(1)` 插入，直到空间满了，再次循环。

这种情况可以不用加权平均来算，可以用 `摊还分析法`，以此得到的复杂度称为 `均摊时间复杂度`。

以 `insert` 为例，`n-1` 次的 `O(1)` 插入后，跟着 `1次 O(n)` 累加，可以把 `O(n)` 均摊到 `n-1` 次操作上，一次空间插满的复杂度均摊下来就是 `O(1)`。

对一个数据结构进行一组连续的操作，大部分时间复杂度都很低，只有个别情况才会比较高，并且这些操作前后有连贯，这时候可以把这些操作放在一起分析，看能不能把耗时高的平摊到耗时低上面去。一般情况下，均摊时间复杂度等于最好情况时间复杂度。

---

## Exercise

```cpp
// 全局变量，大小为10的数组array，长度len，下标i。
int array[] = new int[10];
int len = 10;
int i = 0;

// 往数组中添加一个元素
void add(int element) {
   if (i >= len) { // 数组空间不够了
     // 重新申请一个2倍大小的数组空间
     int new_array[] = new int[len*2];
     // 把原来array数组中的数据依次copy到new_array
     for (int j = 0; j < len; ++j) {
       new_array[j] = array[j];
     }
     // new_array复制给array，array现在大小就是2倍len了
     array = new_array;
     len = 2 * len;
   }
   // 将element放到下标为i的位置，下标i加一
   array[i] = element;
   ++i;
}
```
